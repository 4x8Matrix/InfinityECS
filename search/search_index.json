{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is ECS? ECS stands for Entity-Component-System, an architecture designed for high performance & simplicity. ECS and OOP (Object-Orientated-Programming) share some of the same attributes, however ECS prioritises structure & data orientation There are thee factors when using an ECS system; Component: A property, state or value, as an example; we could add a Force Component to push an object. Entity: A collection of components, entities would be instances inside of the world. System: The logic used to compute what happens with Entity and it's collection of components What is Infinity? Infinity was built to be lightweight and follow the ECS architecture to the dot, when using this framework, your project will have structure and data definition. Infinity was also built with flexibility in mind, it runs in most variations of lua, being tested in the following, LuaJit Love Roblox Vanilla Support Links Discord : Discord Link Other Frameworks There are plenty of frameworks out there to help you design your experience, however, if you don't want to use Infinity, below is a list of frameworks that will help you design your game instead! Sleitnick/Knit [ Knit is a lightweight framework for Roblox that simplifies communication ... ] Sleitnick/AeroGameFramework [ AeroGameFramework is a Roblox game framework that makes development easy ... ] Quenty/NevermoreEngine [Nevermore is a ModuleScript loader for Roblox, and loads modules by name.] astrealRBLX/volt [ An intuitive and feature-packed Roblox game framework. ]","title":"Home"},{"location":"#what-is-ecs","text":"ECS stands for Entity-Component-System, an architecture designed for high performance & simplicity. ECS and OOP (Object-Orientated-Programming) share some of the same attributes, however ECS prioritises structure & data orientation There are thee factors when using an ECS system; Component: A property, state or value, as an example; we could add a Force Component to push an object. Entity: A collection of components, entities would be instances inside of the world. System: The logic used to compute what happens with Entity and it's collection of components","title":"What is ECS?"},{"location":"#what-is-infinity","text":"Infinity was built to be lightweight and follow the ECS architecture to the dot, when using this framework, your project will have structure and data definition. Infinity was also built with flexibility in mind, it runs in most variations of lua, being tested in the following, LuaJit Love Roblox Vanilla","title":"What is Infinity?"},{"location":"#support-links","text":"Discord : Discord Link","title":"Support Links"},{"location":"#other-frameworks","text":"There are plenty of frameworks out there to help you design your experience, however, if you don't want to use Infinity, below is a list of frameworks that will help you design your game instead! Sleitnick/Knit [ Knit is a lightweight framework for Roblox that simplifies communication ... ] Sleitnick/AeroGameFramework [ AeroGameFramework is a Roblox game framework that makes development easy ... ] Quenty/NevermoreEngine [Nevermore is a ModuleScript loader for Roblox, and loads modules by name.] astrealRBLX/volt [ An intuitive and feature-packed Roblox game framework. ]","title":"Other Frameworks"},{"location":"install/","text":"There are two supported ways to install InfinityECS, however you can also add Infinity as a Git Submodule for your project. both of the below methods require you to download the latest GitHub Releases Studio - rbxm binary Download the latest rbxm binary from releases Insert the rbxm into roblox studio Move the model into a suitable location Filesystem - zip archive Download the latest zip Archive from releases Extract the source folder from the Zip Archive into your workspace Rename the source folder to Infinity Git - submodule & rojo CLI Installation: git submodule add https://github.com/4x8Matrix/InfinityECS.git Rojo Configuration: \"ReplicatedStorage\": { ... \"InfinityECS\": { \"$path\": \"Submodules/InfinityECS/source\" }, ... }","title":"Installation"},{"location":"install/#studio-rbxm-binary","text":"Download the latest rbxm binary from releases Insert the rbxm into roblox studio Move the model into a suitable location","title":"Studio - rbxm binary"},{"location":"install/#filesystem-zip-archive","text":"Download the latest zip Archive from releases Extract the source folder from the Zip Archive into your workspace Rename the source folder to Infinity","title":"Filesystem - zip archive"},{"location":"install/#git-submodule-rojo","text":"CLI Installation: git submodule add https://github.com/4x8Matrix/InfinityECS.git Rojo Configuration: \"ReplicatedStorage\": { ... \"InfinityECS\": { \"$path\": \"Submodules/InfinityECS/source\" }, ... }","title":"Git - submodule &amp; rojo"},{"location":"classes/component/","text":"Component Class A component is one of the three elements that build the ECS architecture; This is a piece of data used to influence the behaviour of an entity, world or system. Properties Name Component.Name: String The given name of a component object Id Component.Id: String Short Hexidecimal string used to assign an object a unique string for identification Functions Destroy Component:Destroy(): nil Used to remove a component; Invalidate the component so it's use is no longer valid Concat Component:Concat(Source: String) Will attempt to perform a concentration operation on the data the component is storing Warning If you attempt to do this on an illegal type; Such as a table then this function will raise an exception. Inc Component:Inc(Int: Number) Will attempt to perform an increment operation on the data the component is storing Is Component:Is(...: Any): Any | nil Will compare the data the component is storing to all variations inside of the parameters local Component = Infinity.Component.new(\"MyRawDataValue\") print(Component:Is(\"MyDataValue\")) -- > nil print(Component:Is(\"MyRawDataValue\")) -- > MyRawDataValue print(Component:Is(\"MyDataValue\", \"MyRawDataValue\")) -- > MyRawDataValue Iter Component:Iter(): (Any, Any) | nil Will attempt to iterate through the data the component is storing local Component = Infinity.Component.new({ \"Abc\", \"123\" }) for Index, Value in Component:Iter() do print(Index, Value) end --[[ 1 Abc 2 123 ]]-- Set Component:Set(Value: Any) Will attempt to set the value of the component, overwriting any previous values. Type Component:Type(): String Return the type of data that it is storing, for example a component could be storing a string, userdata, number etc Equal Component:Equal(Component: Component): Boolean Attempt to compare the two component objects, not the data. new Component.new(Value: Any, Name: String): Component Constructor for component objects, this is how you'll create components. Code Example Below is a code example on how we could use some of the above functions; local HealthComponent = Infinity.Component.new(100, \"Health\") local MaxHealthComponent = Infinity.Component.new(100, \"MaxHealth\") local function TakeDamage(Damage: Int) HealthComponent:Inc(-Damage) if HealthComponent:Get() < MaxHealthComponent:Get() then print(\"Entity has died!\") Infinity:Sleep(5) HealthComponent:Set(MaxHealthComponent:Get()) end end","title":"Component"},{"location":"classes/component/#component-class","text":"A component is one of the three elements that build the ECS architecture; This is a piece of data used to influence the behaviour of an entity, world or system.","title":"Component Class"},{"location":"classes/component/#properties","text":"","title":"Properties"},{"location":"classes/component/#name","text":"Component.Name: String The given name of a component object","title":"Name"},{"location":"classes/component/#id","text":"Component.Id: String Short Hexidecimal string used to assign an object a unique string for identification","title":"Id"},{"location":"classes/component/#functions","text":"","title":"Functions"},{"location":"classes/component/#destroy","text":"Component:Destroy(): nil Used to remove a component; Invalidate the component so it's use is no longer valid","title":"Destroy"},{"location":"classes/component/#concat","text":"Component:Concat(Source: String) Will attempt to perform a concentration operation on the data the component is storing Warning If you attempt to do this on an illegal type; Such as a table then this function will raise an exception.","title":"Concat"},{"location":"classes/component/#inc","text":"Component:Inc(Int: Number) Will attempt to perform an increment operation on the data the component is storing","title":"Inc"},{"location":"classes/component/#is","text":"Component:Is(...: Any): Any | nil Will compare the data the component is storing to all variations inside of the parameters local Component = Infinity.Component.new(\"MyRawDataValue\") print(Component:Is(\"MyDataValue\")) -- > nil print(Component:Is(\"MyRawDataValue\")) -- > MyRawDataValue print(Component:Is(\"MyDataValue\", \"MyRawDataValue\")) -- > MyRawDataValue","title":"Is"},{"location":"classes/component/#iter","text":"Component:Iter(): (Any, Any) | nil Will attempt to iterate through the data the component is storing local Component = Infinity.Component.new({ \"Abc\", \"123\" }) for Index, Value in Component:Iter() do print(Index, Value) end --[[ 1 Abc 2 123 ]]--","title":"Iter"},{"location":"classes/component/#set","text":"Component:Set(Value: Any) Will attempt to set the value of the component, overwriting any previous values.","title":"Set"},{"location":"classes/component/#type","text":"Component:Type(): String Return the type of data that it is storing, for example a component could be storing a string, userdata, number etc","title":"Type"},{"location":"classes/component/#equal","text":"Component:Equal(Component: Component): Boolean Attempt to compare the two component objects, not the data.","title":"Equal"},{"location":"classes/component/#new","text":"Component.new(Value: Any, Name: String): Component Constructor for component objects, this is how you'll create components.","title":"new"},{"location":"classes/component/#code-example","text":"Below is a code example on how we could use some of the above functions; local HealthComponent = Infinity.Component.new(100, \"Health\") local MaxHealthComponent = Infinity.Component.new(100, \"MaxHealth\") local function TakeDamage(Damage: Int) HealthComponent:Inc(-Damage) if HealthComponent:Get() < MaxHealthComponent:Get() then print(\"Entity has died!\") Infinity:Sleep(5) HealthComponent:Set(MaxHealthComponent:Get()) end end","title":"Code Example"},{"location":"classes/componentBuilder/","text":"Component Builder Class The component builder class offers a flexible and easy way to build a multitude components; for example, this could be for bulk component generation or nested components in entity generation. Properties Id ComponentBuilder.Id: String Short Hexidecimal string used to assign an object a unique string for identification Functions Build ComponentBuilder:Build(): { [Number]: Component } Build the array of components. local Components = Infinity.ComponentBuilder.new({ ComponentName = \"ComponentValue\" }):Build() --[[ { Component -- Value: \"ComponentValue\", Name: \"ComponentName\" } ]] Update ComponentBuilder:Update(ComponentDict: { [String]: Any }) Will append the ComponentDict to internal components; When calling :Build these components will be appended onto the array of components local ComponentBuilder = Infinity.ComponentBuilder.new({ ComponentName = \"ComponentValue\" }):Update({ ComponentName2 = \"ComponentValue2\" }) new Infinity.ComponentBuilder.new(ComponentDict: { [String]: Any }): ComponentBuilder Initiate a new ComponentBuilder object; The first parameter is all the components you would like to initially add. Code Example local PlayerObject = Infinity.Entity.new( Infinity.ComponentBuilder.new({ IsLoaded = false, DataLoaded = false, Data = { } }) ) --[[ PlayerObject Entity will have the components; - IsLoaded - DataLoaded - Data All three of these will be ComponentObjects/ ]]--","title":"ComponentBuilder"},{"location":"classes/componentBuilder/#component-builder-class","text":"The component builder class offers a flexible and easy way to build a multitude components; for example, this could be for bulk component generation or nested components in entity generation.","title":"Component Builder Class"},{"location":"classes/componentBuilder/#properties","text":"","title":"Properties"},{"location":"classes/componentBuilder/#id","text":"ComponentBuilder.Id: String Short Hexidecimal string used to assign an object a unique string for identification","title":"Id"},{"location":"classes/componentBuilder/#functions","text":"","title":"Functions"},{"location":"classes/componentBuilder/#build","text":"ComponentBuilder:Build(): { [Number]: Component } Build the array of components. local Components = Infinity.ComponentBuilder.new({ ComponentName = \"ComponentValue\" }):Build() --[[ { Component -- Value: \"ComponentValue\", Name: \"ComponentName\" } ]]","title":"Build"},{"location":"classes/componentBuilder/#update","text":"ComponentBuilder:Update(ComponentDict: { [String]: Any }) Will append the ComponentDict to internal components; When calling :Build these components will be appended onto the array of components local ComponentBuilder = Infinity.ComponentBuilder.new({ ComponentName = \"ComponentValue\" }):Update({ ComponentName2 = \"ComponentValue2\" })","title":"Update"},{"location":"classes/componentBuilder/#new","text":"Infinity.ComponentBuilder.new(ComponentDict: { [String]: Any }): ComponentBuilder Initiate a new ComponentBuilder object; The first parameter is all the components you would like to initially add.","title":"new"},{"location":"classes/componentBuilder/#code-example","text":"local PlayerObject = Infinity.Entity.new( Infinity.ComponentBuilder.new({ IsLoaded = false, DataLoaded = false, Data = { } }) ) --[[ PlayerObject Entity will have the components; - IsLoaded - DataLoaded - Data All three of these will be ComponentObjects/ ]]--","title":"Code Example"},{"location":"classes/entity/","text":"Entity Class An entity is one of the three elements that build the ECS architecture; They are the instances in your project. An entity instance is essentially a collection of components, binding multiple things together in order to create a more complicated object Properties Name Entity.Name: String The given name of a Entity object Id Entity.Id: String Short Hexidecimal string used to assign an object a unique string for identification Archetype Entity.Archetype: Archetype The archetype profile which matches this entity Components Entity.Components = { [String]: ComponentObject } Dictionary of all components related to the Entity Warning Never write data to the Components Table; This will cause serve problems when it comes to archetypes and entity components. Functions Destroy Entity:Destroy() Destroys all components attached to the entity object, then will proceed in removing itself from the programs memory. Iter Entity:Iter() Iterate through the Entities components for ComponentName, Component in Entity:Iter() do print(ComponentName, Component) end AddComponent Entity:AddComponent(Component) Adds a single component to the entities registry AddComponents Entity:AddComponents(ComponentA, ComponentB, ...) Adds a multiple components to the entities registry RemoveComponent Entity:RemoveComponent(ComponentName) Removes a single component from the entities registry RemoveComponents Entity:RemoveComponents(ComponentAName, ComponentBName, ...) Removes a multiple components from the entities registry GetComponentsFromType Entity:GetComponentsFromType(Type: String) Construct an array with all entity components that have the specific type Extend Entity:Extend() Create a replica entity, however, the child entity will have a Super reference new Infinity.Entity.new(ComponentsArray: { [Number]: ComponentObject }, Name: String) Initiate a new Entity object Code Sample Below will be an example of a player entity local PlayerObject = Infinity.Entity.new({ Infinity.Component.new(\"SuperCoolName\", \"PlayerName\") })","title":"Entity"},{"location":"classes/entity/#entity-class","text":"An entity is one of the three elements that build the ECS architecture; They are the instances in your project. An entity instance is essentially a collection of components, binding multiple things together in order to create a more complicated object","title":"Entity Class"},{"location":"classes/entity/#properties","text":"","title":"Properties"},{"location":"classes/entity/#name","text":"Entity.Name: String The given name of a Entity object","title":"Name"},{"location":"classes/entity/#id","text":"Entity.Id: String Short Hexidecimal string used to assign an object a unique string for identification","title":"Id"},{"location":"classes/entity/#archetype","text":"Entity.Archetype: Archetype The archetype profile which matches this entity","title":"Archetype"},{"location":"classes/entity/#components","text":"Entity.Components = { [String]: ComponentObject } Dictionary of all components related to the Entity Warning Never write data to the Components Table; This will cause serve problems when it comes to archetypes and entity components.","title":"Components"},{"location":"classes/entity/#functions","text":"","title":"Functions"},{"location":"classes/entity/#destroy","text":"Entity:Destroy() Destroys all components attached to the entity object, then will proceed in removing itself from the programs memory.","title":"Destroy"},{"location":"classes/entity/#iter","text":"Entity:Iter() Iterate through the Entities components for ComponentName, Component in Entity:Iter() do print(ComponentName, Component) end","title":"Iter"},{"location":"classes/entity/#addcomponent","text":"Entity:AddComponent(Component) Adds a single component to the entities registry","title":"AddComponent"},{"location":"classes/entity/#addcomponents","text":"Entity:AddComponents(ComponentA, ComponentB, ...) Adds a multiple components to the entities registry","title":"AddComponents"},{"location":"classes/entity/#removecomponent","text":"Entity:RemoveComponent(ComponentName) Removes a single component from the entities registry","title":"RemoveComponent"},{"location":"classes/entity/#removecomponents","text":"Entity:RemoveComponents(ComponentAName, ComponentBName, ...) Removes a multiple components from the entities registry","title":"RemoveComponents"},{"location":"classes/entity/#getcomponentsfromtype","text":"Entity:GetComponentsFromType(Type: String)","title":"GetComponentsFromType"},{"location":"classes/entity/#construct-an-array-with-all-entity-components-that-have-the-specific-type","text":"","title":"Construct an array with all entity components that have the specific type"},{"location":"classes/entity/#extend","text":"Entity:Extend() Create a replica entity, however, the child entity will have a Super reference","title":"Extend"},{"location":"classes/entity/#new","text":"Infinity.Entity.new(ComponentsArray: { [Number]: ComponentObject }, Name: String) Initiate a new Entity object","title":"new"},{"location":"classes/entity/#code-sample","text":"Below will be an example of a player entity local PlayerObject = Infinity.Entity.new({ Infinity.Component.new(\"SuperCoolName\", \"PlayerName\") })","title":"Code Sample"},{"location":"classes/infinity/","text":"Infinity Class Infinity is the base class which ties together the different objects which make up the ECS architecture, to essentially put it simple; This is going to be the direct point of access for what Infinity has to offer. Info In the case of roblox, we have to make some slight changes to the initialization pipeline in order to maintain performance & simplicity. When ran inside of a roblox environment, things which you would have to implement yourself are no longer needed, this is what we do; Initiate a world object; re-define World in infinity to be this newly created world object. (In roblox, you never seem to have more than one world.) Initiate a RenderStepped or Stepped loop to call Infinity:Update() Properties IsRoblox Infinity.IsRoblox: Boolean True if the scripts environment is running under a roblox game instance Script Infinity.Script: userdata | nil If Infinity.IsRoblox is active then Infinity.Script will be a reference to the roblox script instance IsServer Infinity.IsServer: Boolean | nil If Infinity.IsRoblox is active then Infinity.IsServer then this will define if the framework is ran on the server or client. Classes World Infinity.World: World Reference to the Infinity World Object Query Infinity.Query: Query Reference to the Infinity Query Object Service Infinity.Service: Service Reference to the Infinity Service Object Component Infinity.Component: Component Reference to the Infinity Component Object ComponentBuilder Infinity.ComponentBuilder: ComponentBuilder Reference to the Infinity ComponentBuilder Object EntityManager Infinity.EntityManager: EntityManager Reference to the Infinity EntityManager Object Archetype Infinity.Archetype: EntityArchetype Reference to the Infinity EntityArchetype Object Entity Infinity.Entity: Entity Reference to the Infinity Entity Object System Infinity.System: System Reference to the Infinity System Object SystemController Infinity.SystemController: SystemController Reference to the Infinity SystemController Object Functions GetService Infinity:GetService(ServiceName: String) Attempt to grab either an Infinity Service or Roblox Service through it's ServiceName Update Infinity:Update(DeltaTime: Number) Update the internal InfinityClock, this should only be called when Infinity is not being ran under a roblox environment; It is recomended to call the Update function each render, heartbeat or step inside of your program. Code Sample Below is a demo on how Love could run Infinity local Infinity = require(\".../Infinity\") function love.draw() Infinity:Update() end","title":"Infinity"},{"location":"classes/infinity/#infinity-class","text":"Infinity is the base class which ties together the different objects which make up the ECS architecture, to essentially put it simple; This is going to be the direct point of access for what Infinity has to offer. Info In the case of roblox, we have to make some slight changes to the initialization pipeline in order to maintain performance & simplicity. When ran inside of a roblox environment, things which you would have to implement yourself are no longer needed, this is what we do; Initiate a world object; re-define World in infinity to be this newly created world object. (In roblox, you never seem to have more than one world.) Initiate a RenderStepped or Stepped loop to call Infinity:Update()","title":"Infinity Class"},{"location":"classes/infinity/#properties","text":"","title":"Properties"},{"location":"classes/infinity/#isroblox","text":"Infinity.IsRoblox: Boolean True if the scripts environment is running under a roblox game instance","title":"IsRoblox"},{"location":"classes/infinity/#script","text":"Infinity.Script: userdata | nil If Infinity.IsRoblox is active then Infinity.Script will be a reference to the roblox script instance","title":"Script"},{"location":"classes/infinity/#isserver","text":"Infinity.IsServer: Boolean | nil If Infinity.IsRoblox is active then Infinity.IsServer then this will define if the framework is ran on the server or client.","title":"IsServer"},{"location":"classes/infinity/#classes","text":"","title":"Classes"},{"location":"classes/infinity/#world","text":"Infinity.World: World Reference to the Infinity World Object","title":"World"},{"location":"classes/infinity/#query","text":"Infinity.Query: Query Reference to the Infinity Query Object","title":"Query"},{"location":"classes/infinity/#service","text":"Infinity.Service: Service Reference to the Infinity Service Object","title":"Service"},{"location":"classes/infinity/#component","text":"Infinity.Component: Component Reference to the Infinity Component Object","title":"Component"},{"location":"classes/infinity/#componentbuilder","text":"Infinity.ComponentBuilder: ComponentBuilder Reference to the Infinity ComponentBuilder Object","title":"ComponentBuilder"},{"location":"classes/infinity/#entitymanager","text":"Infinity.EntityManager: EntityManager Reference to the Infinity EntityManager Object","title":"EntityManager"},{"location":"classes/infinity/#archetype","text":"Infinity.Archetype: EntityArchetype Reference to the Infinity EntityArchetype Object","title":"Archetype"},{"location":"classes/infinity/#entity","text":"Infinity.Entity: Entity Reference to the Infinity Entity Object","title":"Entity"},{"location":"classes/infinity/#system","text":"Infinity.System: System Reference to the Infinity System Object","title":"System"},{"location":"classes/infinity/#systemcontroller","text":"Infinity.SystemController: SystemController Reference to the Infinity SystemController Object","title":"SystemController"},{"location":"classes/infinity/#functions","text":"","title":"Functions"},{"location":"classes/infinity/#getservice","text":"Infinity:GetService(ServiceName: String) Attempt to grab either an Infinity Service or Roblox Service through it's ServiceName","title":"GetService"},{"location":"classes/infinity/#update","text":"Infinity:Update(DeltaTime: Number) Update the internal InfinityClock, this should only be called when Infinity is not being ran under a roblox environment; It is recomended to call the Update function each render, heartbeat or step inside of your program.","title":"Update"},{"location":"classes/infinity/#code-sample","text":"Below is a demo on how Love could run Infinity local Infinity = require(\".../Infinity\") function love.draw() Infinity:Update() end","title":"Code Sample"},{"location":"classes/query/","text":"Query Class The query class is an object which can be used to collect entities within the world that contain certain components. This class is useful for going through a huge amount of entities in a world without having significant performance issues. the query class can return two types of arrays, strict arrays and non-strict arrays; Strict arrays will be entities which have only the components in demand, non-strict arrays are entities which have those components and more. Properties Id Query.Id: String Short Hexidecimal string used to assign an object a unique string for identification Functions GetResult Query:GetResult(): { [Number]: EntityObjects } Computes and returns the result of the query. Strict Query:Strict(): QueryObject Sets the query mode to strict. Unstrict Query:Unstrict(): QueryObject Sets the query mode to unstrict. Find Query:Find(ComponentAName: String, ComponentBName: String, ...): QueryObject Append the ComponentNames to the internal query registry Filter Query:Filter(Callback: Function): QueryObject Create a translatin function to help identify what entities you want as a result of this query. local Query = Infinity.Query.new(Infinity.World):Filter(function(Entity, Component) if Entity.Name == \"SpecialCaseEntity\" then -- We dont want to include the special case, however it has all the same components that we're searching for. return false else return true end end) new Infinity.Query.new(Infinity.World) Initiate a new query object, you need to specify what world you'd want to run the query object in. Code Example An example of getting all entities in a world that have a specific component. local Component = Infinity.Component.new(\"Data\", \"ComponentExample\") local World = Infinity.World.new({ Infinity.Entity.new( { Component }, \"EntityName\" ) }, \"MyWorld\") -- <...> local Entities = Infinity.Query.new(World):Find(\"ComponentExample\"):Filter(function(Entity) return Entity.Name == EntityName end):GetResult() print(Entities[1]) -- > EntityName, the entity we created on our third line.","title":"Query"},{"location":"classes/query/#query-class","text":"The query class is an object which can be used to collect entities within the world that contain certain components. This class is useful for going through a huge amount of entities in a world without having significant performance issues. the query class can return two types of arrays, strict arrays and non-strict arrays; Strict arrays will be entities which have only the components in demand, non-strict arrays are entities which have those components and more.","title":"Query Class"},{"location":"classes/query/#properties","text":"","title":"Properties"},{"location":"classes/query/#id","text":"Query.Id: String Short Hexidecimal string used to assign an object a unique string for identification","title":"Id"},{"location":"classes/query/#functions","text":"","title":"Functions"},{"location":"classes/query/#getresult","text":"Query:GetResult(): { [Number]: EntityObjects } Computes and returns the result of the query.","title":"GetResult"},{"location":"classes/query/#strict","text":"Query:Strict(): QueryObject Sets the query mode to strict.","title":"Strict"},{"location":"classes/query/#unstrict","text":"Query:Unstrict(): QueryObject Sets the query mode to unstrict.","title":"Unstrict"},{"location":"classes/query/#find","text":"Query:Find(ComponentAName: String, ComponentBName: String, ...): QueryObject Append the ComponentNames to the internal query registry","title":"Find"},{"location":"classes/query/#filter","text":"Query:Filter(Callback: Function): QueryObject Create a translatin function to help identify what entities you want as a result of this query. local Query = Infinity.Query.new(Infinity.World):Filter(function(Entity, Component) if Entity.Name == \"SpecialCaseEntity\" then -- We dont want to include the special case, however it has all the same components that we're searching for. return false else return true end end)","title":"Filter"},{"location":"classes/query/#new","text":"Infinity.Query.new(Infinity.World) Initiate a new query object, you need to specify what world you'd want to run the query object in.","title":"new"},{"location":"classes/query/#code-example","text":"An example of getting all entities in a world that have a specific component. local Component = Infinity.Component.new(\"Data\", \"ComponentExample\") local World = Infinity.World.new({ Infinity.Entity.new( { Component }, \"EntityName\" ) }, \"MyWorld\") -- <...> local Entities = Infinity.Query.new(World):Find(\"ComponentExample\"):Filter(function(Entity) return Entity.Name == EntityName end):GetResult() print(Entities[1]) -- > EntityName, the entity we created on our third line.","title":"Code Example"},{"location":"classes/service/","text":"Service Class A service is more of a standalone system; It's purpose is to provide you with ways to easily add functions & properties in world systems, for an example; You might want to create a Sound Service to manipulate and handle how sound would occur in your project. Info Using a system as a standalone service is very bad practice, a system is not designed for that usage, however, a service is. Functions new Infinity.Service.new(Data: { [Any]: Any }) Create a new infinity service, the first parameter is used to define what should already be inside of the service; As an example: Infinity.Service.new({ Name = \"MyServiceName\" }) Code Example Below is an example on how we might code the structure to play some sounds in our project; ScriptA: local SoundService = Infinity.Service.new({ Name = \"SoundService\" }) function SoundService:PlaySoundFromSource(Source) --<...> end ScriptB: local SoundService = Infinity:GetService(\"SoundService\") -- we could also do: Infinity.SoundService local function OnDeath() SoundService:PlaySoundFromSource(\"Assets/DeathSoundEffect.mp3\") --<...> end","title":"Service"},{"location":"classes/service/#service-class","text":"A service is more of a standalone system; It's purpose is to provide you with ways to easily add functions & properties in world systems, for an example; You might want to create a Sound Service to manipulate and handle how sound would occur in your project. Info Using a system as a standalone service is very bad practice, a system is not designed for that usage, however, a service is.","title":"Service Class"},{"location":"classes/service/#functions","text":"","title":"Functions"},{"location":"classes/service/#new","text":"Infinity.Service.new(Data: { [Any]: Any }) Create a new infinity service, the first parameter is used to define what should already be inside of the service; As an example: Infinity.Service.new({ Name = \"MyServiceName\" })","title":"new"},{"location":"classes/service/#code-example","text":"Below is an example on how we might code the structure to play some sounds in our project; ScriptA: local SoundService = Infinity.Service.new({ Name = \"SoundService\" }) function SoundService:PlaySoundFromSource(Source) --<...> end ScriptB: local SoundService = Infinity:GetService(\"SoundService\") -- we could also do: Infinity.SoundService local function OnDeath() SoundService:PlaySoundFromSource(\"Assets/DeathSoundEffect.mp3\") --<...> end","title":"Code Example"},{"location":"classes/system/","text":"System Class An system is one of the three elements that build the ECS architecture; This class provides logic for the entities & components inside of the world. An example of this would be; Updating an AI Pathfinding Algorithm to push a block to the next point in 3D Space. Warning A system class needs to have a world; Without a world this system can no longer manipulate any entities or components It is very bad practice to create a system and use it as a service, api or an object to be used inside of Infinity. Properties Id System.Id: String Short Hexidecimal string used to assign an object a unique string for identification Functions PreUpdate System:PreUpdate(DeltaTime: Number): Boolean PreUpdate is a validation function to validate calling :OnUpdate ; This function is fired after every heartbeat (Avg: 60fps) If PreUpdate returns false, or an answer in any way that represents a falsey statement, then the :OnUpdate function will be skipped. A good use-case for this would be a system you only wanted to update each second, you could easily add in a block of code to fire this event after a second has passed. Information This function is designed to be overwritten; If your system is loop driven then you would overwrite this function. OnUpdate System:OnUpdate(DeltaTime: Number): Any, Any, ... OnUpdate will be called by the world object every heartbeat (Avg: 60fps) Any returns will be fed directly into :PostUpdate Information This function is designed to be overwritten; If your system is loop driven then you would overwrite this function. PostUpdate System:PostUpdate(DeltaTime: Number, ...) PostUpdate will be called after :OnUpdate has been called; The 2nd argument of :PostUpdate will be the results of :OnUpdate Information This function is designed to be overwritten; If your system is loop driven then you would overwrite this function so you would be able to factor in the loop logic. Bind System:Bind(EventName: String, EventCallback: Function): Function Bind an event listener to the system, The resulting function should be used to disconnect the current event listener Fire System:Fire(EventName: String, ...) Fire event event listeners binded to EventName with the arguments of ... new Infinity.System.new(): System Initiate a new system object Code Example The code below will show an example on how we coulduse a System; local System = Infinity.System.new() System.Time = 0 function System:PreUpdate(DeltaTime) self.Time = self.Time + DeltaTime if self.Time > 1 then return true end end -- This will only be fired if `PreUpdate` returns true function System:OnUpdate() print(\"This is fired each second!\") print(\"SecondDeltaTime:\", self.Time - 1) end -- This will only be fired if `PreUpdate` returns true function System:PostUpdate() self.Time = 0 end Infinity.World:AddSystems(System)","title":"System"},{"location":"classes/system/#system-class","text":"An system is one of the three elements that build the ECS architecture; This class provides logic for the entities & components inside of the world. An example of this would be; Updating an AI Pathfinding Algorithm to push a block to the next point in 3D Space. Warning A system class needs to have a world; Without a world this system can no longer manipulate any entities or components It is very bad practice to create a system and use it as a service, api or an object to be used inside of Infinity.","title":"System Class"},{"location":"classes/system/#properties","text":"","title":"Properties"},{"location":"classes/system/#id","text":"System.Id: String Short Hexidecimal string used to assign an object a unique string for identification","title":"Id"},{"location":"classes/system/#functions","text":"","title":"Functions"},{"location":"classes/system/#preupdate","text":"System:PreUpdate(DeltaTime: Number): Boolean PreUpdate is a validation function to validate calling :OnUpdate ; This function is fired after every heartbeat (Avg: 60fps) If PreUpdate returns false, or an answer in any way that represents a falsey statement, then the :OnUpdate function will be skipped. A good use-case for this would be a system you only wanted to update each second, you could easily add in a block of code to fire this event after a second has passed. Information This function is designed to be overwritten; If your system is loop driven then you would overwrite this function.","title":"PreUpdate"},{"location":"classes/system/#onupdate","text":"System:OnUpdate(DeltaTime: Number): Any, Any, ... OnUpdate will be called by the world object every heartbeat (Avg: 60fps) Any returns will be fed directly into :PostUpdate Information This function is designed to be overwritten; If your system is loop driven then you would overwrite this function.","title":"OnUpdate"},{"location":"classes/system/#postupdate","text":"System:PostUpdate(DeltaTime: Number, ...) PostUpdate will be called after :OnUpdate has been called; The 2nd argument of :PostUpdate will be the results of :OnUpdate Information This function is designed to be overwritten; If your system is loop driven then you would overwrite this function so you would be able to factor in the loop logic.","title":"PostUpdate"},{"location":"classes/system/#bind","text":"System:Bind(EventName: String, EventCallback: Function): Function Bind an event listener to the system, The resulting function should be used to disconnect the current event listener","title":"Bind"},{"location":"classes/system/#fire","text":"System:Fire(EventName: String, ...) Fire event event listeners binded to EventName with the arguments of ...","title":"Fire"},{"location":"classes/system/#new","text":"Infinity.System.new(): System Initiate a new system object","title":"new"},{"location":"classes/system/#code-example","text":"The code below will show an example on how we coulduse a System; local System = Infinity.System.new() System.Time = 0 function System:PreUpdate(DeltaTime) self.Time = self.Time + DeltaTime if self.Time > 1 then return true end end -- This will only be fired if `PreUpdate` returns true function System:OnUpdate() print(\"This is fired each second!\") print(\"SecondDeltaTime:\", self.Time - 1) end -- This will only be fired if `PreUpdate` returns true function System:PostUpdate() self.Time = 0 end Infinity.World:AddSystems(System)","title":"Code Example"},{"location":"classes/world/","text":"World Class The world class is essentially a container for all systems, entities and components, the world class will push events, handle system clocks and manage the environment of your project. Imagine the world being a space, inside this space will be your systems & entities which work hand-in-hand together in order to achieve something. Another way of looking at a world, would be a Unity Scene, it allows you to store a package inside of one container, this container can then be manipulated in the future. Info If roblox is the environment the framework is being ran in, then the World class will be constructed during runtime of the Infinity Module. For more information please visit Classes -> Infinity Properties Name World.Name: String The given name of a World object Id World.Id: String Short Hexidecimal string used to assign an object a unique string for identification Functions AddEntities World:AddEntities(EntityA: EntityObject, EntityB: EntityObject, ...) Add a list of Entities into the world registry AddSystems World:AddSystems(SystemA: SystemObject, SystemB: SystemObject, ...) Add a list of Systems into the world registry GetEntitiesFromArchetype World:GetEntitiesFromArchetype(Archetype: ArchetypeObject): { [Number]: EntityObject } Returns a collection of entity object which match the archetype specified GetEntitiesFromComponents World:GetEntitiesFromComponents(ComponentA: ComponentObject, ComponentB: ComponentObject): { [Number]: EntityObject } Returns a collection of entity object which match the components specified GetEntitiesFromName World:GetEntitiesFromName(Name: String): { [Number]: EntityObject } Returns a collection of entity object which match the name specified SetState World:SetState(State: Boolean) Set the world state to active/inactive; When the world is inactive, all of the worlds systems, entities and components become idle. Push World:Push(EventName: String, ...) Push an event to all systems binded to the world Update World:Update(DeltaTime: Number) Update all systems binded to the world Destroy World:Destroy() Destroy all systems, entities and components. Then remove itself from the programs memory new Infinity.World.new(Entities: { [Number]: EntityObject }, Name: String) Initiate a new world object Warning If Infinity is being ran on a roblox environment, Infinity.World will be a WorldObject, it is not advised to create a new world object over the default world which will automaically be created. Code Sample In the below example, we create one player and three bad guys inside of the same world. local WorldObject = Infinity.World.new({ Infinity.Entity.new({ Infinity.Component.new(\"SuperCoolName\", \"ObjectName\") }, \"Player\"), Infinity.Entity.new({ Infinity.Component.new(\"SuperCoolName\", \"ObjectName\") }, \"BadGuy\"), Infinity.Entity.new({ Infinity.Component.new(\"SuperCoolName\", \"ObjectName\") }, \"BadGuy\"), Infinity.Entity.new({ Infinity.Component.new(\"SuperCoolName\", \"ObjectName\") }, \"BadGuy\") }) What our systems should do is then add logic to these entities and components; For example a System would collect all entities with the name \"Player\" and have it take 5 HP from all bad guys.","title":"World"},{"location":"classes/world/#world-class","text":"The world class is essentially a container for all systems, entities and components, the world class will push events, handle system clocks and manage the environment of your project. Imagine the world being a space, inside this space will be your systems & entities which work hand-in-hand together in order to achieve something. Another way of looking at a world, would be a Unity Scene, it allows you to store a package inside of one container, this container can then be manipulated in the future. Info If roblox is the environment the framework is being ran in, then the World class will be constructed during runtime of the Infinity Module. For more information please visit Classes -> Infinity","title":"World Class"},{"location":"classes/world/#properties","text":"","title":"Properties"},{"location":"classes/world/#name","text":"World.Name: String The given name of a World object","title":"Name"},{"location":"classes/world/#id","text":"World.Id: String Short Hexidecimal string used to assign an object a unique string for identification","title":"Id"},{"location":"classes/world/#functions","text":"","title":"Functions"},{"location":"classes/world/#addentities","text":"World:AddEntities(EntityA: EntityObject, EntityB: EntityObject, ...) Add a list of Entities into the world registry","title":"AddEntities"},{"location":"classes/world/#addsystems","text":"World:AddSystems(SystemA: SystemObject, SystemB: SystemObject, ...) Add a list of Systems into the world registry","title":"AddSystems"},{"location":"classes/world/#getentitiesfromarchetype","text":"World:GetEntitiesFromArchetype(Archetype: ArchetypeObject): { [Number]: EntityObject } Returns a collection of entity object which match the archetype specified","title":"GetEntitiesFromArchetype"},{"location":"classes/world/#getentitiesfromcomponents","text":"World:GetEntitiesFromComponents(ComponentA: ComponentObject, ComponentB: ComponentObject): { [Number]: EntityObject } Returns a collection of entity object which match the components specified","title":"GetEntitiesFromComponents"},{"location":"classes/world/#getentitiesfromname","text":"World:GetEntitiesFromName(Name: String): { [Number]: EntityObject } Returns a collection of entity object which match the name specified","title":"GetEntitiesFromName"},{"location":"classes/world/#setstate","text":"World:SetState(State: Boolean) Set the world state to active/inactive; When the world is inactive, all of the worlds systems, entities and components become idle.","title":"SetState"},{"location":"classes/world/#push","text":"World:Push(EventName: String, ...) Push an event to all systems binded to the world","title":"Push"},{"location":"classes/world/#update","text":"World:Update(DeltaTime: Number) Update all systems binded to the world","title":"Update"},{"location":"classes/world/#destroy","text":"World:Destroy() Destroy all systems, entities and components. Then remove itself from the programs memory","title":"Destroy"},{"location":"classes/world/#new","text":"Infinity.World.new(Entities: { [Number]: EntityObject }, Name: String) Initiate a new world object Warning If Infinity is being ran on a roblox environment, Infinity.World will be a WorldObject, it is not advised to create a new world object over the default world which will automaically be created.","title":"new"},{"location":"classes/world/#code-sample","text":"In the below example, we create one player and three bad guys inside of the same world. local WorldObject = Infinity.World.new({ Infinity.Entity.new({ Infinity.Component.new(\"SuperCoolName\", \"ObjectName\") }, \"Player\"), Infinity.Entity.new({ Infinity.Component.new(\"SuperCoolName\", \"ObjectName\") }, \"BadGuy\"), Infinity.Entity.new({ Infinity.Component.new(\"SuperCoolName\", \"ObjectName\") }, \"BadGuy\"), Infinity.Entity.new({ Infinity.Component.new(\"SuperCoolName\", \"ObjectName\") }, \"BadGuy\") }) What our systems should do is then add logic to these entities and components; For example a System would collect all entities with the name \"Player\" and have it take 5 HP from all bad guys.","title":"Code Sample"},{"location":"internal/entityArchetype/","text":"The EntityArchetype is a combination of component types, every entity inside of your world will have an archetype account for it; The EntityManager handles the EntityArchetype relationship to Entity classes.","title":"EntityArchetype"},{"location":"internal/entityManager/","text":"The EntityManager's purpose is to provide a stable internal service to manage entities & their archetypes. Every time you initialise a new Entity or add new components to an entity, the entity manager will re-initialise that entities archetype","title":"EntityManager"},{"location":"internal/systemClock/","text":"In most cases, you will never have to use this class; however this is the class which helps to build asynchronous programming into the system, adding a ResumeIn function to yield, resume a thread after a threshold has been exceeded.","title":"SystemClock"},{"location":"internal/systemController/","text":"the system controller is what updates each system sequentially, this class handles and manages the heartbeat of infinity dependant on an FPS variable (Default FPS: 60) Properties Active ??? FPS ???","title":"SystemController"},{"location":"internal/systemController/#properties","text":"","title":"Properties"},{"location":"internal/systemController/#active","text":"???","title":"Active"},{"location":"internal/systemController/#fps","text":"???","title":"FPS"}]}